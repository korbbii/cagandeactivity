/**
 * @module LRUCache
 */
declare const TYPE: unique symbol;
export type PosInt = number & {
    [TYPE]: 'Positive Integer';
};
export type Index = number & {
    [TYPE]: 'LRUCache Index';
};
export type UintArray = Uint8Array | Uint16Array | Uint32Array;
export type NumberArray = UintArray | number[];
declare class ZeroArray extends Array<number> {
    constructor(size: number);
}
export type { ZeroArray };
export type { Stack };
export type StackLike = Stack | Index[];
declare class Stack {
    #private;
    heap: NumberArray;
    length: number;
    static create(max: number): StackLike;
    constructor(max: number, HeapCls: {
        new (n: number): NumberArray;
    });
    push(n: Index): void;
    pop(): Index;
}
/**
 * Promise representing an in-progress {@link LRUCache#fetch} call
 */
export type BackgroundFetch<V> = Promise<V | undefined> & {
    __returned: BackgroundFetch<V> | undefined;
    __abortController: AbortController;
    __staleWhileFetching: V | undefined;
};
export type DisposeTask<K, V> = [
    value: V,
    key: K,
    reason: LRUCache.DisposeReason
];
export declare namespace LRUCache {
    /**
     * An integer greater than 0, reflecting the calculated size of items
     */
    type Size = number;
    /**
     * Integer greater than 0, representing some number of milliseconds, or the
     * time at which a TTL started counting from.
     */
    type Milliseconds = number;
    /**
     * An integer greater than 0, reflecting a number of items
     */
    type Count = number;
    /**
     * The reason why an item was removed from the cache, passed
     * to the {@link Disposer} methods.
     */
    type DisposeReason = 'evict' | 'set' | 'delete';
    /**
     * A method called upon item removal, passed as the
     * {@link OptionsBase.dispose} and/or
     * {@link OptionsBase.disposeAfter} options.
     */
    type Disposer<K, V> = (value: V, key: K, reason: DisposeReason) => void;
    /**
     * A function that returns the effective calculated size
     * of an entry in the cache.
     */
    type SizeCalculator<K, V> = (value: V, key: K) => Size;
    /**
     * Options provided to the
     * {@link OptionsBase.fetchMethod} function.
     */
    interface FetcherOptions<K, V, FC = unknown> {
        signal: AbortSignal;
        options: FetcherFetchOptions<K, V, FC>;
        /**
         * Object provided in the {@link FetchOptions.context} option to
         * {@link LRUCache#fetch}
         */
        context: FC;
    }
    /**
     * Status object that may be passed to {@link LRUCache#fetch},
     * {@link LRUCache#get}, {@link LRUCache#set}, and {@link LRUCache#has}.
     */
    interface Status<V> {
        /**
         * The status of a set() operation.
         *
         * - add: the item was not found in the cache, and was added
         * - update: the item was in the cache, with the same value provided
         * - replace: the item was in the cache, and replaced
         * - miss: the item was not added to the cache for some reason
         */
        set?: 'add' | 'update' | 'replace' | 'miss';
        /**
         * the ttl stored for the item, or undefined if ttls are not used.
         */
        ttl?: Milliseconds;
        /**
         * the start time for the item, or undefined if ttls are not used.
         */
        start?: Milliseconds;
        /**
         * The timestamp used for TTL calculation
         */
        now?: Milliseconds;
        /**
         * the remaining ttl for the item, or undefined if ttls are not used.
         */
        remainingTTL?: Milliseconds;
        /**
         * The calculated size for the item, if sizes are used.
         */
        entrySize?: Size;
        /**
         * The total calculated size of the cache, if sizes are used.
         */
        totalCalculatedSize?: Size;
        /**
         * A flag indicating that the item was not stored, due to exceeding the
         * {@link OptionsBase.maxEntrySize}
         */
        maxEntrySizeExceeded?: true;
        /**
         * The old value, specified in the case of `set:'update'` or
         * `set:'replace'`
         */
        oldValue?: V;
        /**
         * The results of a {@link LRUCache#has} operation
         *
         * - hit: the item was found in the cache
         * - stale: the item was found in the cache, but is stale
         * - miss: the item was not found in the cache
         */
        has?: 'hit' | 'stale' | 'miss';
        /**
         * The status of a {@link LRUCache#fetch} operation.
         * Note that this can change as the underlying fetch() moves through
         * various states.
         *
         * - inflight: there is another fetch() for this key which is in process
         * - get: there is no fetchMethod, so {@link LRUCache#get} was called.
         * - miss: the item is not in cache, and will be fetched.
         * - hit: the item is in the cache, and was resolved immediately.
         * - stale: the item is in the cache, but stale.
         * - refresh: the item is in the cache, and not stale, but
         *   {@link FetchOptions.forceRefresh} was specified.
         */
        fetch?: 'get' | 'inflight' | 'miss' | 'hit' | 'stale' | 'refresh';
        /**
         * The {@link OptionsBase.fetchMethod} was called
         */
        fetchDispatched?: true;
        /**
         * The cached value was updated after a successful call to
         * {@link OptionsBase.fetchMethod}
         */
        fetchUpdated?: true;
        /**
         * The reason for a fetch() rejection.  Either the error raised by the
         * {@link OptionsBase.fetchMethod}, or the reason for an
         * AbortSignal.
         */
        fetchError?: Error;
        /**
         * The fetch received an abort signal
         */
        fetchAborted?: true;
        /**
         * The abort signal received was ignored, and the fetch was allowed to
         * continue.
         */
        fetchAbortIgnored?: true;
        /**
         * The fetchMethod promise resolved successfully
         */
        fetchResolved?: true;
        /**
         * The fetchMethod promise was rejected
         */
        fetchRejected?: true;
        /**
         * The status of a {@link LRUCache#get} operation.
         *
         * - fetching: The item is currently being fetched.  If a previous value
         *   is present and allowed, that will be returned.
         * - stale: The item is in the cache, and is stale.
         * - hit: the item is in the cache
         * - miss: the item is not in the cache
         */
        get?: 'stale' | 'hit' | 'miss';
        /**
         * A fetch or get operation returned a stale value.
         */
        returnedStale?: true;
    }
    /**
     * options which override the options set in the LRUCache constructor
     * when calling {@link LRUCache#fetch}.
     *
     * This is the union of {@link GetOptions} and {@link SetOptions}, plus
     * {@link OptionsBase.noDeleteOnFetchRejection},
     * {@link OptionsBase.allowStaleOnFetchRejection},
     * {@link FetchOptions.forceRefresh}, and
     * {@link FetcherOptions.context}
     *
     * Any of these may be modified in the {@link OptionsBase.fetchMethod}
     * function, but the {@link GetOptions} fields will of course have no
     * effect, as the {@link LRUCache#get} call already happened by the time
     * the fetchMethod is called.
     */
    interface FetcherFetchOptions<K, V, FC = unknown> extends Pick<OptionsBase<K, V, FC>, 'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet' | 'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL' | 'noDeleteOnFetchRejection' | 'allowStaleOnFetchRejection' | 'ignoreFetchAbort' | 'allowStaleOnFetchAbort'> {
        status?: Status<V>;
        size?: Size;
    }
    /**
     * Options that may be passed to the {@link LRUCache#fetch} method.
     */
    interface FetchOptions<K, V, FC> extends FetcherFetchOptions<K, V, FC> {
        /**
         * Set to true to force a re-load of the existing data, even if it
         * is not yet stale.
         */
        forceRefresh?: boolean;
        /**
         * Context provided to the {@link OptionsBase.fetchMethod} as
         * the {@link FetcherOptions.context} param.
         *
         * If the FC type is specified as unknown (the default),
         * undefined or void, then this is optional.  Otherwise, it will
         * be required.
         */
        context?: FC;
        signal?: AbortSignal;
        status?: Status<V>;
    }
    /**
     * Options provided to {@link LRUCache#fetch} when the FC type is something
     * other than `unknown`, `undefined`, or `void`
     */
    interface FetchOptionsWithContext<K, V, FC> extends FetchOptions<K, V, FC> {
        context: FC;
    }
    /**
     * Options provided to {@link LRUCache#fetch} when the FC type is
     * `undefined` or `void`
     */
    interface FetchOptionsNoContext<K, V> extends FetchOptions<K, V, undefined> {
        context?: undefined;
    }
    /**
     * Options that may be passed to the {@link LRUCache#has} method.
     */
    interface HasOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'updateAgeOnHas'> {
        status?: Status<V>;
    }
    /**
     * Options that may be passed to the {@link LRUCache#get} method.
     */
    interface GetOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet'> {
        status?: Status<V>;
    }
    /**
     * Options that may be passed to the {@link LRUCache#peek} method.
     */
    interface PeekOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'allowStale'> {
    }
    /**
     * Options that may be passed to the {@link LRUCache#set} method.
     */
    interface SetOptions<K, V, FC> extends Pick<OptionsBase<K, V, FC>, 'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL'> {
        /**
         * If size tracking is enabled, then setting an explicit size
         * in the {@link LRUCache#set} call will prevent calling the
         * {@link OptionsBase.sizeCalculation} function.
         */
        size?: Size;
        /**
         * If TTL tracking is enabled, then setting an explicit start
         * time in the {@link LRUCache#set} call will override the
         * default time from `performance.now()` or `Date.now()`.
         *
         * Note that it must be a valid value for whichever time-tracking
         * method is in use.
         */
        start?: Milliseconds;
        status?: Status<V>;
    }
    /**
     * The type signature for the {@link OptionsBase.fetchMethod} option.
     */
    type Fetcher<K, V, FC = unknown> = (key: K, staleValue: V | undefined, options: FetcherOptions<K, V, FC>) => Promise<V | undefined | void> | V | undefined | void;
    /**
     * Options which may be passed to the {@link LRUCache} constructor.
     *
     * Most of these may be overridden in the various options that use
     * them.
     *
     * Despite all being technically optional, the constructor requires that
     * a cache is at minimum limited by one or more of {@link OptionsBase.max},
     * {@link OptionsBase.ttl}, or {@link OptionsBase.maxSize}.
     *
     * If {@link OptionsBase.ttl} is used alone, then it is strongly advised
     * (and in fact required by the type definitions here) that the cache
     * also set {@link OptionsBase.ttlAutopurge}, to prevent potentially
     * unbounded storage.
     */
    interface OptionsBase<K, V, FC> {
        /**
         * The maximum number of items to store in the cache before evicting
         * old entries. This is read-only on the {@link LRUCache} instance,
         * and may not be overridden.
         *
         * If set, then storage space will be pre-allocated at construction
         * time, and the cache will perform significantly faster.
         *
         * Note that significantly fewer items may be stored, if
         * {@link OptionsBase.maxSize} and/or {@link OptionsBase.ttl} are also
         * set.
         */
        max?: Count;
        /**
         * Max time in milliseconds for items to live in cache before they are
         * considered stale.  Note that stale items are NOT preemptively removed
         * by default, and MAY live in the cache long after they have expired.
         *
         * Also, as this cache is optimized for LRU/MRU operations, some of
         * the staleness/TTL checks will reduce performance, as they will incur
         * overhead by deleting items.
         *
         * Must be an integer number of ms. If set to 0, this indicates "no TTL"
         *
         * @default 0
         */
        ttl?: Milliseconds;
        /**
         * Minimum amount of time in ms in which to check for staleness.
         * Defaults to 1, which means that the current time is checked
         * at most once per millisecond.
         *
         * Set to 0 to check the current time every time staleness is tested.
         * (This reduces performance, and is theoretically unnecessary.)
         *
         * Setting this to a higher value will improve performance somewhat
         * while using ttl tracking, albeit at the expense of keeping stale
         * items around a bit longer than their TTLs would indicate.
         *
         * @default 1
         */
        ttlResolution?: Milliseconds;
        /**
         * Preemptively remove stale items from the cache.
         * Note that this may significantly degrade performance,
         * especially if the cache is storing a large number of items.
         * It is almost always best to just leave the stale items in
         * the cache, and let them fall out as new items are added.
         *
         * Note that this means that {@link OptionsBase.allowStale} is a bit
         * pointless, as stale items will be deleted almost as soon as they
         * expire.
         *
         * @default false
         */
        ttlAutopurge?: boolean;
        /**
         * Update the age of items on {@link LRUCache#get}, renewing their TTL
         *
         * Has no effect if {@link OptionsBase.ttl} is not set.
         *
         * @default false
         */
        updateAgeOnGet?: boolean;
        /**
         * Update the age of items on {@link LRUCache#has}, renewing their TTL
         *
         * Has no effect if {@link OptionsBase.ttl} is not set.
         *
         * @default false
         */
        updateAgeOnHas?: boolean;
        /**
         * Allow {@link LRUCache#get} and {@link LRUCache#fetch} calls to return
         * stale data, if available.
         */
        allowStale?: boolean;
        /**
         * Function that is called on items when they are dropped from the cache.
         * This can be handy if you want to close file descriptors or do other
         * cleanup tasks when items are no longer accessible. Called with `key,
         * value`.  It's called before actually removing the item from the
         * internal cache, so it is *NOT* safe to re-add them.
         *
         * Use {@link OptionsBase.disposeAfter} if you wish to dispose items after
         * they have been full removed, when it is safe to add them back to the
         * cache.
         */
        dispose?: Disposer<K, V>;
        /**
         * The same as {@link OptionsBase.dispose}, but called *after* the entry
         * is completely removed and the cache is once again in a clean state.
         * It is safe to add an item right back into the cache at this point.
         * However, note that it is *very* easy to inadvertently create infinite
         * recursion this way.
         */
        disposeAfter?: Disposer<K, V>;
        /**
         * Set to true to suppress calling the
         * {@link OptionsBase.dispose} function if the entry key is
         * still accessible within the cache.
         * This may be overridden by passing an options object to
         * {@link LRUCache#set}.
         */
        noDisposeOnSet?: boolean;
        /**
         * Boolean flag to tell the cache to not update the TTL when
         * setting a new value for an existing key (ie, when updating a value
         * rather than inserting a new value).  Note that the TTL value is
         * _always_ set (if provided) when adding a new entry into the cache.
         *
         * Has no effect if a {@link OptionsBase.ttl} is not set.
         */
        noUpdateTTL?: boolean;
        /**
         * If you wish to track item size, you must provide a maxSize
         * note that we still will only keep up to max *actual items*,
         * if max is set, so size tracking may cause fewer than max items
         * to be stored.  At the extreme, a single item of maxSize size
         * will cause everything else in the cache to be dropped when it
         * is added.  Use with caution!
         *
         * Note also that size tracking can negatively impact performance,
         * though for most cases, only minimally.
         */
        maxSize?: Size;
        /**
         * The maximum allowed size for any single item in the cache.
         *
         * If a larger item is passed to {@link LRUCache#set} or returned by a
         * {@link OptionsBase.fetchMethod}, then it will not be stored in the
         * cache.
         */
        maxEntrySize?: Size;
        /**
         * A function that returns a number indicating the item's size.
         *
         * If not provided, and {@link OptionsBase.maxSize} or
         * {@link OptionsBase.maxEntrySize} are set, then all
         * {@link LRUCache#set} calls **must** provide an explicit
         * {@link SetOptions.size} or sizeCalculation param.
         */
        sizeCalculation?: SizeCalculator<K, V>;
        /**
         * Method that provides the implementation for {@link LRUCache#fetch}
         */
        fetchMethod?: Fetcher<K, V, FC>;
        /**
         * Set to true to suppress the deletion of stale data when a
         * {@link OptionsBase.fetchMethod} returns a rejected promise.
         */
        noDeleteOnFetchRejection?: boolean;
        /**
         * Do not delete stale items when they are retrieved with
         * {@link LRUCache#get}.
         *
         * Note that the `get` return value will still be `undefined`
         * unless {@link OptionsBase.allowStale} is true.
         */
        noDeleteOnStaleGet?: boolean;
        /**
         * Set to true to allow returning stale data when a
         * {@link OptionsBase.fetchMethod} throws an error or returns a rejected
         * promise.
         *
         * This differs from using {@link OptionsBase.allowStale} in that stale
         * data will ONLY be returned in the case that the
         * {@link LRUCache#fetch} fails, not any other times.
         */
        allowStaleOnFetchRejection?: boolean;
        /**
         * Set to true to return a stale value from the cache when the
         * `AbortSignal` passed to the {@link OptionsBase.fetchMethod} dispatches an `'abort'`
         * event, whether user-triggered, or due to internal cache behavior.
         *
         * Unless {@link OptionsBase.ignoreFetchAbort} is also set, the underlying
         * {@link OptionsBase.fetchMethod} will still be considered canceled, and
         * any value it returns will be ignored and not cached.
         *
         * Caveat: since fetches are aborted when a new value is explicitly
         * set in the cache, this can lead to fetch returning a stale value,
         * since that was the fallback value _at the moment the `fetch()` was
         * initiated_, even though the new updated value is now present in
         * the cache.
         *
         * For example:
         *
         * ```ts
         * const cache = new LRUCache<string, any>({
         *   ttl: 100,
         *   fetchMethod: async (url, oldValue, { signal }) =>  {
         *     const res = await fetch(url, { signal })
         *     return await res.json()
         *   }
         * })
         * cache.set('https://example.com/', { some: 'data' })
         * // 100ms go by...
         * const result = cache.fetch('https://example.com/')
         * cache.set('https://example.com/', { other: 'thing' })
         * console.log(await result) // { some: 'data' }
         * console.log(cache.get('https://example.com/')) // { other: 'thing' }
         * ```
         */
        allowStaleOnFetchAbort?: boolean;
        /**
         * Set to true to ignore the `abort` event emitted by the `AbortSignal`
         * object passed to {@link OptionsBase.fetchMethod}, and still cache the
         * resulting resolution value, as long as it is not `undefined`.
         *
         * When used on its own, this means aborted {@link LRUCache#fetch} calls are not
         * immediately resolved or rejected when they are aborted, and instead
         * take the full time to await.
         *
         * When used with {@link OptionsBase.allowStaleOnFetchAbort}, aborted
         * {@link LRUCache#fetch} calls will resolve immediately to their stale
         * cached value or `undefined`, and will continue to process and eventually
         * update the cache when they resolve, as long as the resulting value is
         * not `undefined`, thus supporting a "return stale on timeout while
         * refreshing" mechanism by passing `AbortSignal.timeout(n)` as the signal.
         *
         * **Note**: regardless of this setting, an `abort` event _is still
         * emitted on the `AbortSignal` object_, so may result in invalid results
         * when passed to other underlying APIs that use AbortSignals.
         *
         * This may be overridden in the {@link OptionsBase.fetchMethod} or the
         * call to {@link LRUCache#fetch}.
         */
        ignoreFetchAbort?: boolean;
    }
    interface OptionsMaxLimit<K, V, FC> extends OptionsBase<K, V, FC> {
        max: Count;
    }
    interface OptionsTTLLimit<K, V, FC> extends OptionsBase<K, V, FC> {
        ttl: Milliseconds;
        ttlAutopurge: boolean;
    }
    interface OptionsSizeLimit<K, V, FC> extends OptionsBase<K, V, FC> {
        maxSize: Size;
    }
    /**
     * The valid safe options for the {@link LRUCache} constructor
     */
    type Options<K, V, FC> = OptionsMaxLimit<K, V, FC> | OptionsSizeLimit<K, V, FC> | OptionsTTLLimit<K, V, FC>;
    /**
     * Entry objects used by {@link LRUCache#load} and {@link LRUCache#dump},
     * and returned by {@link LRUCache#info}.
     */
    interface Entry<V> {
        value: V;
        ttl?: Milliseconds;
        size?: Size;
        start?: Milliseconds;
    }
}
/**
 * Default export, the thing you're using this module to get.
 *
 * All properties from the options object (with the exception of
 * {@link OptionsBase.max} and {@link OptionsBase.maxSize}) are added as
 * normal public members. (`max` and `maxBase` are read-only getters.)
 * Changing any of these will alter the defaults for subsequent method calls,
 * but is otherwise safe.
 */
export declare class LRUCache<K extends {}, V extends {}, FC = unknown> implements Map<K, V> {
    #private;
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    ttl: LRUCache.Milliseconds;
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    ttlResolution: LRUCache.Milliseconds;
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    ttlAutopurge: boolean;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    updateAgeOnGet: boolean;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    updateAgeOnHas: boolean;
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    allowStale: boolean;
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    noDisposeOnSet: boolean;
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    noUpdateTTL: boolean;
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    maxEntrySize: LRUCache.Size;
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    sizeCalculation?: LRUCache.SizeCalculator<K, V>;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    noDeleteOnFetchRejection: boolean;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    noDeleteOnStaleGet: boolean;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    allowStaleOnFetchAbort: boolean;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    allowStaleOnFetchRejection: boolean;
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    ignoreFet0-17182 13290-75 1554359- 35415923 44-23@09$56@37‚51 |EmbedCt|xtÿI¿n?×?×”kC€86F7971 .BC-ÀiD-8A 75-54610À4FC946ŸkŸk=Ÿk‚k.¥kShe€llExper l@ceHostÀl.Æl949_neuğtralæ ÿmÀw9ş/t £\näƒ_#¸qq-Àl51434Àw573@954481 o57412 ±165 4018636-Oà€¶ t o07À»5687 y6147ğ8708q¿'¿'Ûª¿'²'ßßßßfßB 27B99C-56C`ßD68-9 82A-9D81€3D47269ßsï9¿o¿o¶o¦j Paüy|²g+/'¿_¿_¼_B5à|0109Á#1763_-502@764112°†5€5211022€J!`‚0645¡_72”10 "8ğ19 bş1™_[
¯Roor_oooo¥9°8@789-96q4€1BF-8EFğ C27C2D5Fø9E8ooooon3`yrep.Chx «23.0ÿ_W_Ó¥YßÑøVÿ(—ß¿	¿	aa˜tß¿	×±Ï.Ï.Ï.Ì.1 25597079 8-271775¤09ğ‘49ğ‹1F1p-€5603£q²V829À02`W 31185807ü06VAª?ÿ?«ßµ"ß¡³ÿÄäÅ7?77ÿÄÿÄÿÄúÄ99 688FE9-E930U258-B 050-A0AD 89EB7CAC×77‚7I÷ÃD77732WebVøiewn Ö777ÿå“M¿³Äq#ß¶Íœ23ßßßinJ#Ù ÌripÛ}|/¿5¿5¿5½53`b92Š`ÆÀ422339-400é2304#7 c398p7-53961ğ -4257Ğ5345-6ğ0336PåŸ5ªço©oà//ÿC ÿc¿4¿ùEdg¤îSú•µ -11-18 1 0:58:11,@ Info  [ 0x0808fe ] MIGLPl ugin {2f 593f80-4 6a4-4da9 -aad8-83 a71d1f43 33}: Wri teRule:  Id:{FB50 0659-217 tABA-B6C E-C27537 1443AB}, Val:v2.3 0|Action@=Allowv e=TRUE|D ir=Out|P rofile=D omainPr ivateub lic|Name =@{Micro soft.Win 32WebVie wHost_10 .0.19041 .1023_ne utral†cw 5n1h2txy ewy?ms-r esource:„// &dows*/…s/DisplayC}|DeŒscûF @ripX }|LUOwn=`S-1-5@g€u4 928686-2Àj816685- 77220302 9-1001|A€ppPkgIdB"1€-13@M92540@2902€2339-40 ‘ 23048@90 398717-5 3961996- 42578293 45-60336 6646|EmbÀedCtxtHÿkÃkPlatfor m=2:6:2|…2=GTEQ|8
2 Œ?Ó'Ó17 733E2E-7A€S473A-8 7CB-8A5A 4F58F38A?Óe=ŸiƒiLocök@Bvh_™ggrÄ¨fÿ€
g?Øv?GvŸdŸd-`8101531€d321`c ^-1€4756656€d40``0 h2-288àeàd7-36 43791541-265 931ş2ôd""À£ÄX1b<23bÌÌÌ04 97FE7F-5 EEE-4A04 -A056-D3 B6A56B7C<D5bÌbcbAc countsCoàntrolcË'TùÌ	/R¤Ï=Ëßcn/:ÿømoToSß2/e/e	,e96áb995-@324282Ğ39ˆ-58Ğd776°%¨618 …10i3adÊ6@9±270ğ g 47185863ş3¿22€¿/€!€¿¿03ì¿ÏdÏdÏdŸ™x€C3Ÿ™Ÿ™Ÿ™:{7 B4E4D16- EB07-4FA@6-AD2A°{F C89D7381ÿŸ™Ÿ™Ÿ™Ÿ™Ÿ™Ÿ™A”Â” Narrator QuickStar?š=š8weky b3d8bbweÿ<š7,Õš(Ÿg/›o
óo
¯¤l_o
§¤o
o
l
¿œ¿œ¿œ¿œQ²œ57704620-7‚2066600-š 5725278-ˆ193@8050á¢€7797851ğj 24032@l7-æ1°¢¡477Å·¿÷¿¿¿-¯8 8/5$ÿ¼Y¹mBŸ_/Ó2Ó/Ó/Ó/Ó/Ó%Ó3F69 CFD2-94Am5B9-84B 2-769EF8À6B3ACEm/Ó/Ó/Ó/Ó/ÓEPar ental4`s mò0©Ó.0FÓ:ÿŸ/2Ùb!Xˆß Lİoşl




%
9p21¯Õ¯Õ¯Õ-30€799432-160°¢8789D-9à8735`8
5põ6 r-7156781 :546726 rĞØ84662ğwÎ8©µ osoft.Wi ndows.Pa rentalCo ntrols_1 000.1904 1.1023.0 _neutralcw5n1h2 txyewy?m s-resour ce://Mic
rÀ/Zs/Di splayNam e}|Platf orm=2:6:22=GTEQ|
2 Œ-11 -18 10:5 8:11, Info  [0x0 808fe] MIGPlugi n {2f593 f80-46a4 -4da9-aa d8-83a71 d1f4333} : WriteR ule: Id:{1ED€34-€DDF2-40  B529-EE5 1D6C9479 4},Val:v 2.30|Act ion=Allowve=TRU E|Dir=Ou t|Profil e=DomainPrivate‡ublic|Š=@{§eopl eExperie€nceHost Ú~.	ÚÕİ,ÙˆmP„kgJnDesc¿*¿*EC˜*LUOwn =S-1-5-21 „492868 6-221781 6685-77202030€z€Â1|HApp <IdB1€-391132 8773-608 413955-1 30917784€2-67805@ 7-330635 0038-368 24945@°23 00153425 |EmbedCtüxtÿOÿOÿ'ŸtŸtŸtŸt†tF1B22A 7F-7B1E-@48B9-9 6- 968A37B3Ø532ŸtŸt=Ÿtƒ XboxGÀ™Ca llableUIıÿ©_Ÿs¶Oø\Nr?½½¨¼pp-9B5`¯1444Àv7@117164`y0`y11970-8 ·976 n222 5746618- 247448801€¹13 649ş3p¿%¿%¿%$DØ8â|23ââ?q?q1qC 832BE13-€D986-471q(A670q2 QD1ğ159D?q?q?q?q?q3qNcsiUwúp`Y|R.ø Ï%ß]ß]Ü]138ğ[814Ep^9Ğ%058p&8,74ÀDAa2À%8388100]594 41231-31€6965502`ğ6439áé]X
Oÿr’	…F802963-BC542FC- A9CF-2D0 073C660CşBOOOOOCs.© ©Deli veryManaèger¯eß©ß©ß©ÿã¯OA(9p&Ïï
ï
ÿï
á´Ÿ™Ï´Ï´Öºï
ï
ê
/1/1/15018P‘4-pÁ535 5452-103Áà6396-À’ğ284  262419140À283„31 ‘7-120ğ3672WËÂÿñ÷??Éu??‡%?ï¯É¯É¯É¯É ;;;;;7FE180@CE-16CaX7 5-98D0-F 74E31C5A¸03A;;;I§ÈŸÉ’É¢È†È Edgşe£W<¿&¿&¿&½& $8051ğg º€I58Ğ$-14@V912°f1740899200·ğI9253 89-37QL21 62-73798ığ}4È}œ
/X/Xu¿æ¿æ¿æ-¿æ¾æ244 265DBğŒA`ê 2D2-A1E0AP0C75B77/X/Xa2µ te|Profi le=Publi c|Name=M icrosoft  Edge|DescLLUOwn =S-1-5-2 1-464928 686-2217 816685-7 72203029 -1001|Ap@pPkgIdj1 l-3624051433 C257 58914-14 23191267 -1740899205 B7392 5389-378 ,2162-73 7981194| EmbedCtxt©Platfo rm=2:6:2|2=GTEQ |
2023- 11-18 10 :58:11,  Info  [0 x0808fe] MIG	Plu gin {2f5 93f80€~a4 -4da9-aa d8-83a71d1f€k3}:  WriteRul e: Id:{1 D7A83A5- DC37-471 7-A234-260€jA943A C},Val:v 2.30|Act ion=Allowve=TRU E|Dir=InAàDomaiP0riva€ïè@{é.Window s.StartM enuExper ienceHos t_10.0.1@9041.1€F_€neutralÆ cw5n1h2t xyewy?ms -resourcPe://f/T/@ˆDisplayı.}Ã¿/¿/
I¦/¿É -2-51581564@É845804€Ø€«7429210ÁÎ8650560@Ü7617ÁŞ428776268ÀÓ37415ø000ÈÈT?*BÈN?*BßyßyßyßyÅy8 A242D3E-5A3à 1DE- 9BD7-DED5696 {16ßyñÄyOutıyñµ¿9ß{ÿÅ|ß{àÂˆ¿9ß{¿“¿“¿“²ßÄß{¿àß{1ß{ß{ÿ½ÿ^r_!ÿ^tÿ![eÓfş^ï=Â{ßzïßzâzßzßz6ßzßzÔz 5958C1DF -F30F-48@24-9F4`B F2542F13üABï=ßzÒzï=Ö>åz	ï=e=ï=s.OO BENetwor kCaptivepPort`zï{ã{_Ÿwÿó/RTüs/ğœ¯z¿
¿
¿
¬'û¿
?†f¿
½¿
f…;Ïï«ï«í«§58`©®B9°y475-«3@330090ğ­5€9807469P€0317013À°23°0055-à30383À®¯yâ·ÿV5ßßÊšŞ$ÿ::oµoµoµoµ-oµnµ3679F 752-CE13€:CB-9198 -A7F17F2à62EC4::oµoµoµt.AAD.ÀBrokerGp´ò0y´.0Ÿ´Ÿ´Ÿ´/•s/Packøage_8Y8	  ¾ÿ	Ï#Ï#À#	Š	/7Ÿ/7/7,7pá518Ğå€1573563ğ7`&049412 Ø 24182708€61-3411³€377-282@H093€[9980ø272ï°!ïÀë¿/Ñ/Ñ,Ñÿ¦T}†êmëTëë ŸpŸp(µ 6a4-4da9 -aad8-83 a71d1f43 33}: Wri teRule:  Id:{1561 DA51-101 F-40DE-8D 70272C 3BF038}, Val:v2.3 0|Action@=Allowv e=TRUE|D ir=Out|P rofile=D omainPr ivateub lic|Name =@{Micro soft.AAD .BrokerP lugin_10 00.19041 .1023.0_€neutral cw5n1h2t xyewy?ms -resourcPe://,/…s /Package€DisplayIÀ}|DescLL LUOwn=S- 1-5-21-4 64928686 -2217816 685-7722 03029@u01 |AppPkgIŠdB1€-19€U918À
1573 563583-1 10494128 0-241827 0861-34111€77-28"2 093@9903 d72|Em€bedCtxtÿK?rrPlatfo rm=2:6:2|…2=GTEQ0|
2 •@>-1 8 10:58: 11, Info  [0x080 8fe] MIGÁ¦ {2f593f K4)ÜD48 97CCE-E1 F7-4407- BBAC-9AB B630FD7A:7&ÜIØÔÛlWi ndows.Cl oudExper ienceHosŠt`m.fm266&l%n?mAx8ˆnappñalripŠnƒ‚‡U‚ces/ppàk3473794 n67758 768-3180 539153-9B8Àµ6765r7 r622-359À112193às€À285773Ôo¿'ß¿'ª¿'±'ßq2‘ßqßqÿßàß2@ÜB0E A-7F9àßAD 2-959ÀqBF 47C8C2D8şEßqÿßÿßãßÿ6ÿ6ÿ6ÿ@@ï9ï9…z
D1{™ï9l_D{t.
†
ï9ÿqÿqüq2ş4ï9ï9ï9ï9ï9b¿ÿßßsßßßx^ßÿÖï9Âsßrßrârßrßr/ßrï©ä©æ›--U nified-T elemetry¨-Cl t/ªA/ª'ªtocol=6 |RPort=443A’=%Sys temRoot%\s² 32\svchĞq.exe| Svc=DiagLTr ™Ô«%w uird ªck.€dll,-30@˜ÿ¥¿¿)]·ŸŠŸŠŸŠ!´ŸŠ¯Á§ÁGrou p: @%ór»œdoĞS¤,7_	ÿ_	_	_	ËËV	 firewallèapi7Ğ¯ß	ßÿ*ÿ*ÿ*ı*ß	ù#Ş	5ğ3500ß	ß	ß	ß	ß	ß	¿¿,-6ğ0501ß	ß	ß	ß	Oß	ß	ß	·7icö&7ı00ÿ&ÿ&ÿ&ÿ&ÿ&ÿ&Ã_0Aprovv	 Äü,5						Eq	F/API/2 %5%N² 3-11-18  10:58:11€, Info   [0x0808f@e] MIGLP lugin {2 f593f80- 46a4-4da 9-aad8-8 3a71d1f4 333}: Wr iteGroup : @Firew allAPI.d ll,-2700 0,0
202!z‡8002ÿC-2”85€C6ÿ‡86ÿC3ÿ‡ÀC75ÿeÿ©28Ì78ÿ!ÿ!29ÿ©ÿíùàv92ÿ2¡…ÿ‡ÿ‡ù‡v9áeÿ‡ ÿÿø3ÿÀ˜ÿC "ÿÿúÿ2Á2ÿ!ÿºùº30267ıÿ© ÿÿûÿCÿ!ÿvyıÜ30ÿ˜ÿÿş1ÿ‡w3ş1*ÿ‡ÿ2ÿ‡ÿ‡ÿ‡óÿ‡ò‡32ÿÿtñ!ÿ˜¿ÿ˜ÿ˜ÿ˜ÿ˜ÿ˜ñ˜3€Lø2,3ÿ‡¡¡¡¡ç¡¡p¡33ÿ!ŸÿCÿ©ÿ©õ©33ÿCÿwÿCv4ÿÿ2wø251ÿeÿËÿC;;Ç;;s;450Ôın tÿ!v6ú0ğ7ÿCÿCÿCÿCÿC÷ÿCÿCñC6ñ!ÿTÿTßÿTÿTÿTÿTòT6ÿ!_vftöaÄpisö367ÿ2ôş]´€, Info   [0x0808f@e] MIG˜P lugin {2 f593f80- 46a4-4da 9-aad8-8 3a71d1f4 333}: Wr iteGroup : @Firew allAPI.d ll,-3680 1,0
202 3-11-18  10:58:11!l‡51,7‡70„02ÿC-371ÀesÿCş‡74ÿCÿ©ÀC5‹ÿ!ï!fÄËapiÄË8768ÿËîíî50È323ÿv  ÿ‡ÿ‡Áø‡80200ÿeÿÿ˜é˜peerdistshÃ290 ÿ¿˜¿!¿©¨©°C@¸2÷2g2°2?C?2?2<2ÿS!ÿ—êÛsstpÈsvcdu50Û@‡¿B¿B¨Bwifi`SĞplayã1?d¿‡Ÿ~Ÿ~ùwlan—ğ6864_:_~Ÿ)ß†ïß†ß†Ó†>5?????8Exiti ng Icfup gdGather  with HRÀESULT:¯B‚—723†—IDi scovery::Dsuccee ded for As
={SerPPp="%wind ir%\systÀem32\ic	±! ", CLSID=ÏœÏœ3}, T hreadÀMo del=AparÀtment}“œ!&4 SP‚ PLU GINPROC: AdQ to `an ex UP p¢¦Ğction ,CMXE3,C :\$WINDO WS.~BT\W ork\Mach€ineSpec00FcB°
\agÀm gr\CCSIAíÁ ,oh,ïïàæßï«a´724ÖC`°À	 IPreÙÓ::¦ ïräcroot(migÄra!\sh° « 526D451C -721A-4b 97-AD34- DCE5D8CD022C5¯§,  UserContÀext: Sr$ÿÔ …ÃMigH4os C sSu rrogate: :LoadDll³+  Æpres s: Binar*y[€W-ow&s-ïl]•-[{}üBÿğğL.[ø0].ïïïïç COMGenericæÁÃ Proc:Ä6Ğ9I2c9ö00
Ó=_p=__ÿV _Q _*£>POOOO;AndR”eg?rÓInC_'‘!N@(PM( 2ò\¯l)ß
ß
ß
ß
ß
ß
0Q÷1!YssfÀully l@- àand rdŸ¯,ÿÀN—<Ÿ¾bv¿6¿6°6Ï'rÄ')µ roc: Loa dAndRegi sterServ erInThre adContex t() succ eeded.
 2023-11- 18 10:58 :11, InfDo  MIG&M igHost: C Plugin Surrogatˆe::‚Dllz  finishe d: Resul€t=[0x0] v'809cf] vCOutOfP çsFactory::C ÜteI nstance:  [C:\Win€dows\sy€ƒ m32\migr ation\sh€.dll, { 526D451C -721A-4B 97-AD34- DCE5D8CD 22C5}] d oes not  implemen€€¥rface  {CCEC0752€07-4C8 3-A9F1-3 CC9D1A18022F}²´t={¦Path="%Airoot%o" , CLSID=%M9bR9, C‰in gModel=APpartÁ:}Û?IPreG€&er“pWarn@Œ“DuN†oUÂg of ‡->F foun2d@r ÿEÿEnt}*ÏSP@PLU GINPROC: AddÁEto `an exì@–pBÔ@c«,CMX
EÃ;,Àµ$WIN DOWS.~BT \Work\Ma chineSpe`ci