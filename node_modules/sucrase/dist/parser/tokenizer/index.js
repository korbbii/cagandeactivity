"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }/* eslint max-len: 0 */

var _base = require('../traverser/base');
var _util = require('../traverser/util');
var _charcodes = require('../util/charcodes');
var _identifier = require('../util/identifier');
var _whitespace = require('../util/whitespace');
var _keywords = require('./keywords');
var _readWord = require('./readWord'); var _readWord2 = _interopRequireDefault(_readWord);
var _types = require('./types');

var IdentifierRole; (function (IdentifierRole) {
  const Access = 0; IdentifierRole[IdentifierRole["Access"] = Access] = "Access";
  const ExportAccess = Access + 1; IdentifierRole[IdentifierRole["ExportAccess"] = ExportAccess] = "ExportAccess";
  const TopLevelDeclaration = ExportAccess + 1; IdentifierRole[IdentifierRole["TopLevelDeclaration"] = TopLevelDeclaration] = "TopLevelDeclaration";
  const FunctionScopedDeclaration = TopLevelDeclaration + 1; IdentifierRole[IdentifierRole["FunctionScopedDeclaration"] = FunctionScopedDeclaration] = "FunctionScopedDeclaration";
  const BlockScopedDeclaration = FunctionScopedDeclaration + 1; IdentifierRole[IdentifierRole["BlockScopedDeclaration"] = BlockScopedDeclaration] = "BlockScopedDeclaration";
  const ObjectShorthandTopLevelDeclaration = BlockScopedDeclaration + 1; IdentifierRole[IdentifierRole["ObjectShorthandTopLevelDeclaration"] = ObjectShorthandTopLevelDeclaration] = "ObjectShorthandTopLevelDeclaration";
  const ObjectShorthandFunctionScopedDeclaration = ObjectShorthandTopLevelDeclaration + 1; IdentifierRole[IdentifierRole["ObjectShorthandFunctionScopedDeclaration"] = ObjectShorthandFunctionScopedDeclaration] = "ObjectShorthandFunctionScopedDeclaration";
  const ObjectShorthandBlockScopedDeclaration = ObjectShorthandFunctionScopedDeclaration + 1; IdentifierRole[IdentifierRole["ObjectShorthandBlockScopedDeclaration"] = ObjectShorthandBlockScopedDeclaration] = "ObjectShorthandBlockScopedDeclaration";
  const ObjectShorthand = ObjectShorthandBlockScopedDeclaration + 1; IdentifierRole[IdentifierRole["ObjectShorthand"] = ObjectShorthand] = "ObjectShorthand";
  // Any identifier bound in an import statement, e.g. both A and b from
  // `import A, * as b from 'A';`
  const ImportDeclaration = ObjectShorthand + 1; IdentifierRole[IdentifierRole["ImportDeclaration"] = ImportDeclaration] = "ImportDeclaration";
  const ObjectKey = ImportDeclaration + 1; IdentifierRole[IdentifierRole["ObjectKey"] = ObjectKey] = "ObjectKey";
  // The `foo` in `import {foo as bar} from "./abc";`.
  const ImportAccess = ObjectKey + 1; IdentifierRole[IdentifierRole["ImportAccess"] = ImportAccess] = "ImportAccess";
})(IdentifierRole || (exports.IdentifierRole = IdentifierRole = {}));

/**
 * Extra information on jsxTagStart tokens, used to determine which of the three
 * jsx functions are called in the automatic transform.
 */
var JSXRole; (function (JSXRole) {
  // The element is self-closing or has a body that resolves to empty. We
  // shouldn't emit children at all in this case.
  const NoChildren = 0; JSXRole[JSXRole["NoChildren"] = NoChildren] = "NoChildren";
  // The element has a single explicit child, which might still be an arbitrary
  // expression like an array. We should emit that expression as the children.
  const OneChild = NoChildren + 1; JSXRole[JSXRole["OneChild"] = OneChild] = "OneChild";
  // The element has at least two explicitly-specified children or has spread
  // children, so child positions are assumed to be "static". We should wrap
  // these children in an array.
  const StaticChildren = OneChild + 1; JSXRole[JSXRole["StaticChildren"] = StaticChildren] = "StaticChildren";
  // The element has a prop named "key" after a prop spread, so we should fall
  // back to the createElement function.
  const KeyAfterPropSpread = StaticChildren + 1; JSXRole[JSXRole["KeyAfterPropSpread"] = KeyAfterPropSpread] = "KeyAfterPropSpread";
})(JSXRole || (exports.JSXRole = JSXRole = {}));

 function isDeclaration(token) {
  const role = token.identifierRole;
  return (
    role === IdentifierRole.TopLevelDeclaration ||
    role === IdentifierRole.FunctionScopedDeclaration ||
    role === IdentifierRole.BlockScopedDeclaration ||
    role === IdentifierRole.ObjectShorthandTopLevelDeclaration ||
    role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration ||
    role === IdentifierRole.ObjectShorthandBlockScopedDeclaration
  );
} exports.isDeclaration = isDeclaration;

 function isNonTopLevelDeclaration(token) {
  const role = token.identifierRole;
  return (
    role === IdentifierRole.FunctionScopedDeclaration ||
    role === IdentifierRole.BlockScopedDeclaration ||
    role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration ||
    role === IdentifierRole.ObjectShorthandBlockScopedDeclaration
  );
} exports.isNonTopLevelDeclaration = isNonTopLevelDeclaration;

 function isTopLevelDeclaration(token) {
  const role = token.identifierRole;
  return (
    role === IdentifierRole.TopLevelDeclaration ||
    role === IdentifierRole.ObjectShorthandTopLevelDeclaration ||
    role === IdentifierRole.ImportDeclaration
  );
} exports.isTopLevelDeclaration = isTopLevelDeclaration;

 function isBlockScopedDeclaration(token) {
  const role = token.identifierRole;
  // Treat top-level declarations as block scope since the distinction doesn't matter here.
  return (
    role === IdentifierRole.TopLevelDeclaration ||
    role === IdentifierRole.BlockScopedDeclaration ||
    role === IdentifierRole.ObjectShorthandTopLevelDeclaration ||
    role === IdentifierRole.ObjectShorthandBlockScopedDeclaration
  );
} exports.isBlockScopedDeclaration = isBlockScopedDeclaration;

 function isFunctionScopedDeclaration(token) {
  const role = token.identifierRole;
  return (
    role === IdentifierRole.FunctionScopedDeclaration ||
    role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration
  );
} exports.isFunctionScopedDeclaration = isFunctionScopedDeclaration;

 function isObjectShorthandDeclaration(token) {
  return (
    token.identifierRole === IdentifierRole.ObjectShorthandTopLevelDeclaration ||
    token.identifierRole === IdentifierRole.ObjectShorthandBlockScopedDeclaration ||
    token.identifierRole === IdentifierRole.ObjectShorthandFunctionScopedDeclaration
  );
} exports.isObjectShorthandDeclaration = isObjectShorthandDeclaration;

// Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.
 class Token {
  constructor() {
    this.type = _base.state.type;
    this.contextualKeyword = _base.state.contextualKeyword;
    this.start = _base.state.start;
    this.end = _base.state.end;
    this.scopeDepth = _base.state.scopeDepth;
    this.isType = _base.state.isType;
    this.identifierRole = null;
    this.jsxRole = null;
    this.shadowsGlobal = false;
    this.isAsyncOperation = false;
    this.contextId = null;
    this.rhsEndIndex = null;
    this.isExpression = false;
    this.numNullishCoalesceStarts = 0;
    this.numNullishCoalesceEnds = 0;
    this.isOptionalChainStart = false;
    this.isOptionalChainEnd = false;
    this.subscriptStartIndex = null;
    this.nullishStartIndex = null;
  }

  
  
  
  
  
  
  
  
  // Initially false for all tokens, then may be computed in a follow-up step that does scope
  // analysis.
  
  // Initially false for all tokens, but may be set during transform to mark it as containing an
  // await operation.
  
  
  // For assignments, the index of the RHS. For export tokens, the end of the export.
  
  // For class tokens, records if the class is a class expression or a class statement.
  
  // Number of times to insert a `nullishCoalesce(` snippet before this token.
  
  // Number of times to insert a `)` snippet after this token.
  
  // If true, insert an `optionalChain([` snippet before this token.
  
  // If true, insert a `])` snippet after this token.
  
  // Tag for `.`, `?.`, `[`, `?.[`, `(`, and `?.(` to denote the "root" token for this
  // subscript chain. This can be used to determine if this chain is an optional chain.
  
  // Tag for `??` operators to denote the root token for this nullish coalescing call.
  
} exports.Token = Token;

// ## Tokenizer

// Move to the next token
 function next() {
  _base.state.tokens.push(new Token());
  nextToken();
} exports.next = next;

// Call instead of next when inside a template, since that needs to be handled differently.
 function nextTemplateToken() {
  _base.state.tokens.push(new Token());
  _base.state.start = _base.state.pos;
  readTmplToken();
} exports.nextTemplateToken = nextTemplateToken;

// The tokenizer never parses regexes by default. Instead, the parser is responsible for
// instructing it to parse a regex when we see a slash at the start of an expression.
 function retokenizeSlashAsRegex() {
  if (_base.state.type === _types.TokenType.assign) {
    --_base.state.pos;
  }
  readRegexp();
} exports.retokenizeSlashAsRegex = retokenizeSlashAsRegex;

 function pushTypeContext(existingTokensInType) {
  for (let i = _base.state.tokens.length - existingTokensInType; i < _base.state.tokens.length; i++) {
    _base.state.tokens[i].isType = true;
  }
  const oldIsType = _base.state.isType;
  _base.state.isType = true;
  return oldIsType;
} exports.pushTypeContext = pushTypeContext;

 function popTypeContext(oldIsType) {
  _base.state.isType = oldIsType;
} exports.popTypeContext = popTypeContext;

 function eat(type) {
  if (match(type)) {
    next();
    return true;
  } else {
    return false;
  }
} exports.eat = eat;

 function eatTypeToken(tokenType) {
  const oldIsType = _base.state.isType;
  _base.state.isType = true;
  eat(tokenType);
  _base.state.isType = oldIsType;
} exports.eatTypeToken = eatTypeToken;

 function match(type) {
  return _base.state.type === type;
} exports.match = match;

 function lookaheadType() {
  const snapshot = _base.state.snapshot();
  next();
  const type = _base.state.type;
  _base.state.restoreFromSnapshot(snapshot);
  return type;
} exports.lookaheadType = lookaheadType;

 class TypeAndKeyword {
  
  
  constructor(type, contextualKeyword) {
    this.type = type;
    this.contextualKeyword = contextualKeyword;
  }
} exports.TypeAndKeyword = TypeAndKeyword;

 function lookaheadTypeAndKeyword() {
  const snapshot = _base.state.snapshot();
  next();
  const type = _base.state.type;
  const contextualKeyword = _base.state.contextualKeyword;
  _base.state.restoreFromSnapshot(snapshot);
  return new TypeAndKeyword(type, contextualKeyword);
} exports.lookaheadTypeAndKeyword = lookaheadTypeAndKeyword;

 function nextTokenStart() {
  return nextTokenStartSince(_base.state.pos);
} exports.nextTokenStart = nextTokenStart;

 function nextTokenStartSince(pos) {
  _whitespace.skipWhiteSpace.lastIndex = pos;
  const skip = _whitespace.skipWhiteSpace.exec(_base.input);
  return pos + skip[0].length;
} exports.nextTokenStartSince = nextTokenStartSince;

 function lookaheadCharCode() {
  return _base.input.charCodeAt(nextTokenStart());
} exports.lookaheadCharCode = lookaheadCharCode;

// Read a single token, updating the parser object's token-related
// properties.
 function nextToken() {
  skipSpace();
  _base.state.start = _base.state.pos;
  if (_base.state.pos >= _base.input.length) {
    const tokens = _base.state.tokens;
    // We normally run past the end a bit, but if we're way past the end, avoid an infinite loop.
    // Also check the token positions rather than the types since sometimes we rewrite the token
    // type to something else.
    if (
      tokens.length >= 2 &&
      tokens[tokens.length - 1].start >= _base.input.length &&
      tokens[tokens.length - 2].start >= _base.input.length
    ) {
      _util.unexpected.call(void 0, "Unexpectedly reached the end of input.");
    }
    finishToken(_types.TokenType.eof);
    return;
  }
  readToken(_base.input.charCodeAt(_base.state.pos));
} exports.nextToken = nextToken;

function readToken(code) {
  // Identifier or keyword. '\uXXXX' sequences are allowed in
  // identifiers, so '\' also dispatches to that.
  if (
    _identifier.IS_IDENTIFIER_START[code] ||
    code === _charcodes.charCodes.backslash ||
    (code === _charcodes.charCodes.atSign && _base.input.charCodeAt(_base.state.pos + 1) === _charcodes.charCodes.atSign)
  ) {
    _readWord2.default.call(void 0, );
  } else {
    getTokenFromCode(code);
  }
}

function skipBlockComment() {
  while (
    _base.input.charCodeAt(_base.state.pos) !== _charcodes.charCodes.asterisk ||
    _base.input.charCodeAt(_base.state.pos + 1) !== _charcodes.charCodes.slash
  ) {
    _base.state.pos++;
    if (_base.state.pos > _base.input.length) {
      _util.unexpected.call(void 0, "Unterminated comment", _base.state.pos - 2);
      return;
    }
  }
  _base.state.pos += 2;
}

 function skipLineComment(startSkip) {
  let ch = _base.input.charCodeAt((_base.state.pos += startSkip));
  if (_base.state.pos < _base.input.length) {
    while (
      ch !== _charcodes.charCodes.lineFeed &&
      ch !== _charcodes.charCodes.carriageReturn &&
      ch !== _charcodes.charCodes.lineSeparator &&
      ch !== _charcodes.charCodes.paragraphSeparator &&
      ++_base.state.pos < _base.input.length
    ) {
      ch = _base.input.charCodeAt(_base.state.pos);
    }
  }
} exports.skipLineComment = skipLineComment;

// Called at the start of the parse and after every token. Skips
// whitespace and comments.
 function skipSpace() {
  while (_base.state.pos < _base.input.length) {
    const ch = _base.input.charCodeAt(_base.state.pos);
    switch (ch) {
      case _charcodes.charCodes.carriageReturn:
        if (_base.input.charCodeAt(_base.state.pos + 1) === _charcodes.charCodes.lineFeed) {
          ++_base.state.pos;
        }

      case _charcodes.charCodes.lineFeed:
      case _charcodes.charCodes.lineSeparator:
      case _charcodes.charCodes.paragraphSeparator:
        ++_base.state.pos;
        break;

      case _charcodes.charCodes.slash:
        switch (_base.input.charCodeAt(_base.state.pos + 1)) {
          case _charcodes.charCodes.asterisk:
            _base.state.pos += 2;
            skipBlockComment();
            break;

          case _charcodes.charCodes.slash:
            skipLineComment(2);
            break;

          default:
            return;
        }
        break;

      default:
        if (_whitespace.IS_WHITESPACE[ch]) {
          ++_base.state.pos;
        } else {
          return;
        }
    }
  }
} exports.skipSpace = skipSpace;

// Called at the end of every token. Sets various fields, and skips the space after the token, so
// that the next one's `start` will point at the right position.
 function finishToken(
  type,
  contextualKeyword = _keywords.ContextualKeyword.NONE,
) {
  _base.state.end = _base.state.pos;
  _base.state.type = type;
  _base.state.contextualKeyword = contextualKeyword;
} exports.finishToken = finishToken;

// ### Token reading

// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
function readToken_dot() {
  const nextChar = _base.input.charCodeAt(_base.state.pos + 1);
  if (nextChar >= _charcodes.charCodes.digit0 && nextChar <= _charcodes.charCodes.digit9) {
    readNumber(true);
    return;
  }

  if (nextChar === _charcodes.charCodes.dot && _base.input.charCodeAt(_base.state.pos + 2) === _charcodes.charCodes.dot) {
    _base.state.pos += 3;
    finishToken(_types.TokenType.ellipsis);
  } else {
    ++_base.state.pos;
    finishToken(_types.TokenType.dot);
  }
}

function readToken_slash() {
  const nextChar = _base.input.charCodeAt(_base.state.pos + 1);
  if (nextChar === _charcodes.charCodes.equalsTo) {
    finishOp(_types.TokenType.assign, 2);
  } else {
    finishOp(_types.TokenType.slash, 1);
  }
}

function readToken_mult_modulo(code) {
  // '%*'
  let tokenType = code === _charcodes.charCodes.asterisk ? _types.TokenType.star : _types.TokenType.modulo;
  let width = 1;
  let nextChar = _base.input.charCodeAt(_base.state.pos + 1);

  // Exponentiation operator **
  if (codÿÿ  ÿÿÿ                            ÎÎÎÎ€             ŽÎÎÎÎÎÎÈ           ÎÎÎÎÎÎÎÎà          ÎÎÎÎÎlìììn         ÎÎÎÎoìììììà        ŒììììïŽÎÎÎÎÈ        ìììììoøììììì        ÎÎÎÎÎÏÿönÎÎÎ       nÎnÎfïøÿÎÎÎfà      ìììììÏþüìììà      ÎÎÎÎÎïüèÿììì`      ŒììÿÎÆÏüìÿŽÎÎÈ      ììæÿöìïþÎÏøììî      ìììèøìïüìÿüììì      ÎÎÎÎüïöïøìììì      ììììèÿÏüÿŽÎÎÎÎ      nÎÎÎÎÿÿøììììì      ÎÎÎÎÎÏÿÿŽÎÎÎÎÎ      ììììììÿÿÎÎÎÎlì      ÎÎÎÎÎÎøìììììæ      ìììænÏÿÿþÎÎÎÎÎ      ÎÎnÎÎÿøøììììì      ììììèøïþŽÎÎÎÎ      ÎÎÎÎŒïüèÿÎlìì      ìììèÿìïüìÿüìæÎ      ŽÎÎÿŒìÏþÎÏøììè      ŒììˆìæïüìÿŽÎÎÎ      ÎÎÎÎÎÏþÏÿÎÎÎÀ      ìììììïüÿŽÎÎÎ`      ÎÎÎÎÎÏÿøììììà       ìæìììïÿŽÎÎÎÎ        ÎÎÎÎÎÏÿÎÎÎnÎ        ŽÎÎÎÎoþÎÎÎÎÈ        ÎÎÎÎÏÎÎÎÎÎÀ         lìììæììììì          ÎÎÎÎÎÎÎnÀ           ŽÎÎÎÎÎlè             ììììà                           ÿÿÿÿÿ   ÿþ ÿ   ÿð ÿ   ÿà ÿ   ÿÀ ÿ   ÿ€ ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   þ      þ      þ      ü   ?   ü   ?   ü   ?   ü   ?   ü   ?   ü   ?   ü   ?   ü   ?   ü   ?   ü   ?   ü   ?   ü   ?   ü   ?   ü   ?   ü   ?   ü   ?   þ      þ      þ      ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ€ ÿ   ÿÀ ÿ   ÿà ÿ   ÿð ÿ   ÿþ ÿ   ÿÿÿÿÿ   (       @                                  €  €   €€ €   € € €€  €€€ ÀÀÀ   ÿ  ÿ   ÿÿ ÿ   ÿ ÿ ÿÿ  ÿÿÿ                       ìììæ          ìììììì€        ìììììììè       ÎÎÎÏnÎÎÎ€      ÎÎÎoüìììà      ììììïÿnÎÎÎ      ÎÎÎÎÏÿŒììì      ììììïøÿììì     ÎÎŽÎÏþŽÎÎ€    ÎÈøìïüèÿlìà    ìîŽÏöÏøììà    ÎÌèÿoþÿüììà    ìæÎÿøøìænÀ    ìììèÿÿüìììà    ÎÎÎÎøììììà    ììììÿÿÎÎÎÎÀ    ÎÎnÏÿÿþÎÎÎÀ    ììlÿÿøøìììà    ÎÎïøïþöìæÀ    ììÿŽÏüèøÎÎà    ÎÈøìïüèÿììp    ÎnŒìoþŒììà     ììììïøÿììì      ÎÎÎÎÏÿŒììæ      ììììïÿììæÎ      ÎÎÎÏüìììà      ÎÎÎhìììì€       ìììììììî        ìììììì€          ìììç                      ÿÿÿÿÿðÿÿ€ÿÿ  ÿþ  þ  ü  ?ü  ?ü  ?ø  ø  ø  ø  ø  ø  ø  ø  ø  ø  ø  ø  ø  ø  ü  ?ü  ?ü  ?þ  þ  ÿ  ÿÿ€ÿÿðÿÿÿÿÿ(      0                                  €  €   €€ €   € € €€  €€€ ÀÀÀ   ÿ  ÿ   ÿÿ ÿ   ÿ ÿ ÿÿ  ÿÿÿ     ŽÎÎÎ       Œììììè     ÎÎÎÎÎÎp    ììïìììà    ììì÷ììì    ÎÎÎïÿnÎÎ    ìììˆüìì   ÎÎ~Ïìÿììà  ÎÏþ~ÿ~Î€  Înøˆüììà  ììÿøìììà  ÎÎÎÿþÎÎÎÀ  ìììÿüìììà  ÎÎÿÿìììà  ììÿïþÎÎÀ  ÎÏþÏìÿ~Îp  nÎÎ~ÿÎÎÀ   ÎÎlïˆþÎÎ    ìììÿÎÎÎ    ìììïþÎÎÎ    ÎÎÎÎÎÀ    ìììììì€     ŽÎÎÎÎÎ       ŽÎÎh    ÿ ÿ ü ? ø  ø  ð  ð  ð  à  à  à  à  à  à  à  à  à  à  ð  ð  ð  ø  ø  ü ? ÿ ÿ (      (         ð                         €  €   €€ €   € € €€  €€€ ÀÀÀ   ÿ  ÿ   ÿÿ ÿ   ÿ ÿ ÿÿ  ÿÿÿ    ŽÎÎÈ       ÎÎÎìà      ÎÎÎlìì      ììïŒìæ     ÎÎÏþÎÎp    ììïŒìà    ÎˆÏÎþÎÀ    ìïïèøìà    ŽÎÈÿìÎÈ    Œììï÷Îìè    îÎÎþÎÎÎ    ŒìèŒìè    ÎïÎþÎÀ    ìŽÏèøìà    ÎÎÏìÎÀ    ÎÎÏ÷Îìà     ììïììn      nÎÈÎÎÎ      ììììà       ŽÎÎè     üð øð ð ð ð ð à p à p à p à p À 0 À 0 À 0 À 0 à p à p à p à p ð ð ð ð øð üð (                €                         €  €   €€ €   € € €€  €€€ ÀÀÀ   ÿ  ÿ   ÿÿ ÿ   ÿ ÿ ÿÿ  ÿÿÿ   ÎÎ`    ÎÎÎÎ   ÎÏììà  ìïŽÎÀ  æìïlè  ÎÏÈþÎ  ìèÿïìì  ÎÎüìì  ììþÎÎ  ÎÈÿïŒì  ìïïÈþÎ  ŽÎÏìç  ìïŽÎÀ  ÎÈììà   lììì    ÎÎÀ  ø  ð  à  à  À  À  À  À  À  À  À  À  à  à  ð  ø  (   0   `          	                    ü‚  ü‰ ü‘ ü™/ ýš0 ü ? ý©P ý°_ ý±` ý¸o ýÀ ÿðà ÿøð                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ÿÿÿ                                                                   

                                                                                                                                                              ÿ                    ÿÿ                   ÿÿÿ                  ÿÿÿÿ                 
ÿÿÿÿÿ
                ÿÿÿÿÿ                ÿÿÿÿÿ                	ÿÿÿÿÿ               ÿÿÿÿÿÿÿ              ÿÿÿÿÿ	ÿÿÿ              ÿÿÿÿÿÿÿ              ÿÿÿÿÿÿÿ              ÿÿÿÿÿÿÿ              ÿÿÿÿÿÿÿ              ÿÿÿÿÿÿÿ              ÿÿÿÿÿ              ÿÿÿ              ÿÿÿ              ÿÿÿÿÿ              ÿÿÿÿÿÿÿ              ÿÿÿÿÿÿÿ              ÿÿÿÿÿÿÿ              ÿÿÿÿÿÿÿ              ÿÿÿÿÿÿÿ              ÿÿÿÿÿ	ÿÿÿ              ÿÿÿÿÿÿÿ               ÿÿÿÿÿ                ÿÿÿÿÿ                ÿÿÿÿÿ                
ÿÿÿÿÿ
                 ÿÿÿÿ                  ÿÿÿ                   ÿÿ                    ÿ                                                                                                                                                              

                                                                  ÿÿÿÿÿÿ  ÿÿÀÿÿ  ÿþ  ÿ  ÿü  ?ÿ  ÿø  ÿ  ÿð  ÿ  ÿà  ÿ  ÿÀ  ÿ  ÿÀ  ÿ  ÿ€  ÿ  ÿ€  ÿ  ÿ    ÿ  ÿ    ÿ  ÿ    ÿ  ÿ    ÿ  þ      þ      þ      þ      þ      þ      þ      þ      þ      þ      þ      þ      þ      þ      þ      þ      þ      þ      ÿ    ÿ  ÿ    ÿ  ÿ    ÿ  ÿ    ÿ  ÿ€  ÿ  ÿ€  ÿ  ÿÀ  ÿ  ÿÀ  ÿ  ÿà  ÿ  ÿð  ÿ  ÿø  ÿ  ÿü  ?ÿ  ÿþ  ÿ  ÿÿÀÿÿ  ÿÿÿÿÿÿ  (   (   P         @                    ü‚  ü‰ üŠ ü‘ ü’  ü™/ ü ? ü¨O ýÀ þÐ  þØ° þèÐ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ÿÿÿ                                                                                   		                                                                                	ÿ	                ÿÿ                ÿÿÿ               ÿÿÿ              ÿÿÿ              ÿÿÿ             	ÿÿÿ	            ÿÿÿÿÿ
            ÿÿÿÿ            ÿÿÿÿ            ÿÿÿÿ            ÿÿÿÿ            ÿÿÿÿ            ÿÿ            ÿÿ            ÿÿÿÿ            ÿÿÿÿ            ÿÿÿÿ            ÿÿÿÿ            ÿÿÿÿ            ÿÿÿÿÿ
            	ÿÿÿ	             ÿÿÿ              ÿÿÿ              ÿÿÿ               ÿÿÿ                ÿÿ                	ÿ	                                                                                		                                                                                  ÿÿÿÿÿ   ÿþ ÿ   ÿð ÿ   ÿà ÿ   ÿÀ ÿ   ÿ€ ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   þ      þ      þ      ü   ?   ü   ?   ü   ?   ü   ?   ü   ?   ü   ?   ü   ?   ü   ?   ü   ?   ü   ?   ü   ?   ü   ?   ü   ?   ü   ?   ü   ?   ü   ?   þ      þ      þ      ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ€ ÿ   ÿÀ ÿ   ÿà ÿ   ÿð ÿ   ÿþ ÿ   ÿÿÿÿÿ   (       @                              ü‚  üŠ ü ? ü¨O ý°_ ý¸o ýÀ þÁ€ þÐ  þèÐ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ÿÿÿ                                                                                                  
              ÿ
             ÿÿ
            ÿÿÿ
            ÿÿ
ÿ
           ÿÿ
ÿ
          ÿ
ÿÿ
ÿ
          
ÿ
ÿÿ
ÿ
          
ÿ
ÿÿ
ÿ
          
ÿ
ÿÿ
ÿ
          
ÿÿÿÿ
          
ÿÿ
          
ÿÿ
          
ÿÿÿÿ
          
ÿ
ÿÿ
ÿ
          
ÿ
ÿÿ
ÿ
          
ÿ
ÿÿ
ÿ
          ÿ
ÿÿ
ÿ
          	ÿÿ
ÿ
           ÿÿ
ÿ
            ÿÿÿ
            ÿÿ
             ÿ
              
                                                                                                 ÿÿÿÿÿðÿÿ€ÿÿ  ÿþ  þ  ü  ?ü  ?ü  ?ø  ø  ø  ø  ø  ø  ø  ø  ø  ø  ø  ø  ø  ø  ü  ?ü  ?ü  ?þ  þ  ÿ  ÿÿ€ÿÿðÿÿÿÿÿ(      0         @                    ü‚  ü‰ ü‘ ýš0 ü ? ý¡@ ü¨O ý°_ ý¹p ÿðà ÿøð                                                                                                                                                                         xpected.call(void 0, "Unterminated regular expression", start);
      return;
    }
    const code = _base.input.charCodeAt(_base.state.pos);
    if (escaped) {
      escaped = false;
    } else {
      if (code === _charcodes.charCodes.leftSquareBracket) {
        inClass = true;
      } else if (code === _charcodes.charCodes.rightSquareBracket && inClass) {
        inClass = false;
      } else if (code === _charcodes.charCodes.slash && !inClass) {
        break;
      }
      escaped = code === _charcodes.charCodes.backslash;
    }
    ++_base.state.pos;
  }
  ++_base.state.pos;
  // Need to use `skipWord` because '\uXXXX' sequences are allowed here (don't ask).
  skipWord();

  finishToken(_types.TokenType.regexp);
}

/**
 * Read a decimal integer. Note that this can't be unified with the similar code
 * in readRadixNumber (which also handles hex digits) because "e" needs to be
 * the end of the integer so that we can properly handle scientific notation.
 */
function readInt() {
  while (true) {
    const code = _base.input.charCodeAt(_base.state.pos);
    if ((code >= _charcodes.charCodes.digit0 && code <= _charcodes.charCodes.digit9) || code === _charcodes.charCodes.underscore) {
      _base.state.pos++;
    } else {
      break;
    }
  }
}

function readRadixNumber() {
  _base.state.pos += 2; // 0x

  // Walk to the end of the number, allowing hex digits.
  while (true) {
    const code = _base.input.charCodeAt(_base.state.pos);
    if (
      (code >= _charcodes.charCodes.digit0 && code <= _charcodes.charCodes.digit9) ||
      (code >= _charcodes.charCodes.lowercaseA && code <= _charcodes.charCodes.lowercaseF) ||
      (code >= _charcodes.charCodes.uppercaseA && code <= _charcodes.charCodes.uppercaseF) ||
      code === _charcodes.charCodes.underscore
    ) {
      _base.state.pos++;
    } else {
      break;
    }
  }

  const nextChar = _base.input.charCodeAt(_base.state.pos);
  if (nextChar === _charcodes.charCodes.lowercaseN) {
    ++_base.state.pos;
    finishToken(_types.TokenType.bigint);
  } else {
    finishToken(_types.TokenType.num);
  }
}

// Read an integer, octal integer, or floating-point number.
function readNumber(startsWithDot) {
  let isBigInt = false;
  let isDecimal = false;

  if (!startsWithDot) {
    readInt();
  }

  let nextChar = _base.input.charCodeAt(_base.state.pos);
  if (nextChar === _charcodes.charCodes.dot) {
    ++_base.state.pos;
    readInt();
    nextChar = _base.input.charCodeAt(_base.state.pos);
  }

  if (nextChar === _charcodes.charCodes.uppercaseE || nextChar === _charcodes.charCodes.lowercaseE) {
    nextChar = _base.input.charCodeAt(++_base.state.pos);
    if (nextChar === _charcodes.charCodes.plusSign || nextChar === _charcodes.charCodes.dash) {
      ++_base.state.pos;
    }
    readInt();
    nextChar = _base.input.charCodeAt(_base.state.pos);
  }

  if (nextChar === _charcodes.charCodes.lowercaseN) {
    ++_base.state.pos;
    isBigInt = true;
  } else if (nextChar === _charcodes.charCodes.lowercaseM) {
    ++_base.state.pos;
    isDecimal = true;
  }

  if (isBigInt) {
    finishToken(_types.TokenType.bigint);
    return;
  }

  if (isDecimal) {
    finishToken(_types.TokenType.decimal);
    return;
  }

  finishToken(_types.TokenType.num);
}

function readString(quote) {
  _base.state.pos++;
  for (;;) {
    if (_base.state.pos >= _base.input.length) {
      _util.unexpected.call(void 0, "Unterminated string constant");
      return;
    }
    const ch = _base.input.charCodeAt(_base.state.pos);
    if (ch === _charcodes.charCodes.backslash) {
      _base.state.pos++;
    } else if (ch === quote) {
      break;
    }
    _base.state.pos++;
  }
  _base.state.pos++;
  finishToken(_types.TokenType.string);
}

// Reads template string tokens.
function readTmplToken() {
  for (;;) {
    if (_base.state.pos >= _base.input.length) {
      _util.unexpected.call(void 0, "Unterminated template");
      return;
    }
    const ch = _base.input.charCodeAt(_base.state.pos);
    if (
      ch === _charcodes.charCodes.graveAccent ||
      (ch === _charcodes.charCodes.dollarSign && _base.input.charCodeAt(_base.state.pos + 1) === _charcodes.charCodes.leftCurlyBrace)
    ) {
      if (_base.state.pos === _base.state.start && match(_types.TokenType.template)) {
        if (ch === _charcodes.charCodes.dollarSign) {
          _base.state.pos += 2;
          finishToken(_types.TokenType.dollarBraceL);
          return;
        } else {
          ++_base.state.pos;
          finishToken(_types.TokenType.backQuote);
          return;
        }
      }
      finishToken(_types.TokenType.template);
      return;
    }
    if (ch === _charcodes.charCodes.backslash) {
      _base.state.pos++;
    }
    _base.state.pos++;
  }
}

// Skip to the end of the current word. Note that this is the same as the snippet at the end of
// readWord, but calling skipWord from readWord seems to slightly hurt performance from some rough
// measurements.
 function skipWord() {
  while (_base.state.pos < _base.input.length) {
    const ch = _base.input.charCodeAt(_base.state.pos);
    if (_identifier.IS_IDENTIFIER_CHAR[ch]) {
      _base.state.pos++;
    } else if (ch === _charcodes.charCodes.backslash) {
      // \u
      _base.state.pos += 2;
      if (_base.input.charCodeAt(_base.state.pos) === _charcodes.charCodes.leftCurlyBrace) {
        while (
          _base.state.pos < _base.input.length &&
          _base.input.charCodeAt(_base.state.pos) !== _charcodes.charCodes.rightCurlyBrace
        ) {
          _base.state.pos++;
        }
        _base.state.pos++;
      }
    } else {
      break;
    }
  }
} exports.skipWord = skipWord;
